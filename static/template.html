<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>{{.Title}}</title>
	<link rel="stylesheet" href="static/style.css">
	<link rel="stylesheet" href="static/highlight.js/styles/ascetic.css">
	<script src="static/highlight.js/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	</head>

	<body>
    <div id="content"> <span id="status"></span>
      <h1>{{.Title}}</h1>
      <p>{{.Splash}}</p>
      <p>Example</p>
        {{with .Gallery}}
        {{range .}}
		{{if .Valid}}
        <a class="thumb" href="images/{{.ImageSrc}}" style="background-image:url('images/thumbs/{{.Image}}')">&nbsp;</a>
		{{end}}{{end}}{{end}}
	<p>Quotes</p>
	<blockquote><strong>1972</strong> - Dennis Ritchie invents a powerful gun that shoots both forward and backward simultaneously. Not satisfied with the number of 
deaths and permanent maimings from that invention he invents C and Unix.</blockquote>
<br />
<blockquote><strong>1995</strong> - At a neighborhood Italian restaurant Rasmus Lerdorf realizes that his plate of spaghetti is an excellent model for understanding 
the World Wide Web and that web applications should mimic their medium. On the back of his napkin he designs Programmable Hyperlinked 
Pasta (PHP). PHP documentation remains on that napkin to this day.</blockquote>
	<p>Source</p>
	<pre><code>package pages

import (
	&quot;github.com/nfnt/resize&quot;
	&quot;html/template&quot;
	&quot;image&quot;
	&quot;image/gif&quot;
	&quot;image/jpeg&quot;
	&quot;image/png&quot;
	&quot;log&quot;
	&quot;net/http&quot;
	&quot;os&quot;
	&quot;path&quot;
	&quot;sort&quot;
)

type GalleryT struct {
	Image    string
	ImageSrc string
	Valid    bool
}
type Page struct {
	Title   string
	Splash  string
	Gallery []GalleryT
}

type byModTime []os.FileInfo

func (f byModTime) Len() int           { return len(f) }
func (f byModTime) Less(i, j int) bool { return f[i].ModTime().Unix() &gt; f[j].ModTime().Unix() }
func (f byModTime) Swap(i, j int)      { f[i], f[j] = f[j], f[i] }

// Default Request Handler
func DefaultHandler(w http.ResponseWriter, r *http.Request) {
	log.Printf(&quot;Handling request for %s&quot;, r.RemoteAddr)
	p := &amp;Page{Title: &quot;thetooth.name&quot;}
	p.Splash = &quot;Hello&quot;

	d, err := os.Open(&quot;images/&quot;)
	if err != nil {
		log.Println(err)
		os.Exit(1)
	}
	fi, err := d.Readdir(-1)
	if err != nil {
		log.Println(err)
		os.Exit(1)
	}

	sort.Sort(byModTime(fi))
	p.Gallery = make([]GalleryT, len(fi))

	sem := make(chan string, len(fi))
	for i, v := range fi {
		go func(ch chan&lt;- string, i int, v os.FileInfo) {
			if !v.IsDir() {
				switch path.Ext(v.Name()) {
				case &quot;.jpg&quot;:
				case &quot;.jpeg&quot;:
				case &quot;.png&quot;:
				case &quot;.gif&quot;:
					break
				default:
					ch &lt;- &quot;Not an image&quot;
					return
				}
				//log.Print(&quot;Image: &quot; + v.Name() + &quot; &quot; + v.ModTime().String())
				resizeName := v.Name()[0:(len(v.Name())-len(path.Ext(v.Name())))] + &quot;.png&quot;

				_, err := os.Stat(&quot;images/thumbs/&quot; + resizeName)
				if os.IsNotExist(err) {
					log.Println(&quot;Generating thumbnail: &quot; + resizeName)
					file, err := os.Open(&quot;images/&quot; + v.Name())
					defer file.Close()
					if err != nil {
						log.Println(err)
						ch &lt;- &quot;Cannot open image file&quot;
						return
					}

					var source image.Image = nil
					var thumb image.Image = nil
					switch path.Ext(v.Name()) {
					case &quot;.jpg&quot;:
						source, err = jpeg.Decode(file)
						break
					case &quot;.png&quot;:
						source, err = png.Decode(file)
						break
					case &quot;.gif&quot;:
						source, err = gif.Decode(file)
						break
					default:
						ch &lt;- &quot;Image decode missmatch&quot;
						return
					}
					if err != nil {
						log.Println(err)
						thumb = image.NewRGBA(image.Rect(0, 0, 96, 96))
					} else {
						thumb = resize.Resize(0, 96, source, resize.Lanczos3)
					}

					out, err := os.Create(&quot;images/thumbs/&quot; + resizeName)
					defer out.Close()
					if err != nil {
						log.Println(err)
						ch &lt;- &quot;Cannot open destination thumbnail file&quot;
						return
					}

					png.Encode(out, thumb)
				}
				p.Gallery[i] = GalleryT{resizeName, v.Name(), true}
			}
			ch &lt;- &quot;&quot;
		}(sem, i, v)
	}
	for i := 0; i &lt; len(fi); i++ {
		status := &lt;-sem
		if status != &quot;&quot; {
			log.Printf(&quot;Channel %d exited with status \&quot;%s\&quot;.&quot;, i, status)
		}
	}

	t, _ := template.ParseFiles(&quot;static/template.html&quot;)
	t.Execute(w, p)

	log.Printf(&quot;Request final for %s&quot;, r.RemoteAddr)
}
</code></pre>
<p>Want more? <strong>Go fuck yourself :D DDD</strong></p>
    </div>
</body>
</html>
